<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Speech to Text Chatbot</title>
</head>
<body>
    <button id="start-recording">Start Recording</button>
    <button id="stop-recording" disabled>Stop Recording</button>
    <div id="output"></div>
    <script>
    let socket;
    let mediaRecorder;
    let audioChunks = [];
    const SILENCE_THRESHOLD = 1000; // ms of silence before stopping
    const VOLUME_THRESHOLD = 0.01; // Adjust this value based on sensitivity
    let silenceTimer;
    let analyser;

    document.getElementById('start-recording').addEventListener('click', async () => {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);
        
        mediaRecorder = new MediaRecorder(stream);
        
        mediaRecorder.ondataavailable = event => {
            audioChunks.push(event.data);
        };
        mediaRecorder.onstop = () => {
            const audioBlob = new Blob(audioChunks, { 'type' : 'audio/wav' });
            audioChunks = [];
            socket.send(audioBlob);
        };
        mediaRecorder.start();
        document.getElementById('start-recording').disabled = true;
        document.getElementById('stop-recording').disabled = false;

        // Silence detection logic
        function checkSilence() {
            const buffer = new Float32Array(analyser.frequencyBinCount);
            analyser.getFloatTimeDomainData(buffer);
            const maxAmplitude = Math.max(...buffer.map(Math.abs));
            
            if (maxAmplitude < VOLUME_THRESHOLD) {
                if (!silenceTimer) {
                    silenceTimer = setTimeout(() => {
                        if (mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                            document.getElementById('start-recording').disabled = false;
                            document.getElementById('stop-recording').disabled = true;
                        }
                        silenceTimer = null;
                    }, SILENCE_THRESHOLD);
                }
            } else {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }
        }

        // Check for silence periodically
        const silenceInterval = setInterval(checkSilence, 100);

        // Clear interval when recording stops
        mediaRecorder.onstop = () => {
            clearInterval(silenceInterval);
            const audioBlob = new Blob(audioChunks, { 'type' : 'audio/wav' });
            audioChunks = [];
            socket.send(audioBlob);
        };
    });

    document.getElementById('stop-recording').addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
            document.getElementById('stop-recording').disabled = true;
            document.getElementById('start-recording').disabled = false;
        }
    });

    // Setup WebSocket connection to localhost:8765
    socket = new WebSocket('ws://localhost:8765');
    socket.onmessage = function(event) {
        document.getElementById('output').innerText += "\nReceived: " + event.data;
    };
    socket.onopen = function(event) {
        document.getElementById('output').innerText = "WebSocket is open now.";
    };
    socket.onclose = function(event) {
        document.getElementById('output').innerText = "WebSocket is closed now.";
    };
    socket.onerror = function(error) {
        console.error('WebSocket Error:', error);
    };
    </script>
</body>
</html>
